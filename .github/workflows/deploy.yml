name: Deploy

on:
  push:
    branches: ["master"]
  workflow_dispatch:
    inputs:
      promote:
        description: "Promote current commit to prod"
        required: false
        default: "true"
      setup_secrets:
        description: "Setup/update secrets (requires admin permissions)"
        required: false
        default: "false"

env:
  NODE_VERSION: 20
  DOCKER_PLATFORM: linux/amd64
  # Cloud Run
  CR_PORT: 5000
  CR_CONCURRENCY: 80
  CR_TIMEOUT: 900s
  CR_ENV_NODE: production
  CR_ENV_API_BASE: /api/v1
  # Secrets we require in Secret Manager (names = env var names used at runtime)
  REQUIRED_SECRETS: "UPLOADS_ALLOWED_MIME MONGODB_URI GCS_BUCKET_UPLOADS CLERK_ISSUER CLERK_AUDIENCE"

jobs:
  # Optional job to setup/update secrets - requires admin service account
  setup-secrets:
    if: ${{ github.event.inputs.setup_secrets == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    environment: infrastructure
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Auth to GCP (Admin Service Account)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER_ADMIN }}
          service_account: ${{ secrets.GCP_SA_ADMIN_EMAIL }}
          audience: 'https://github.com/akibrahimug/portfolio'

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure GCP project
        run: gcloud config set project "${{ secrets.GCP_PROJECT }}"

      - name: Setup secrets in Secret Manager
        shell: bash
        run: |
          set -euo pipefail
          PROJECT="${{ secrets.GCP_PROJECT }}"
          DEPLOY_SA="${{ secrets.GCP_SA_EMAIL }}"
          
          # Map Secret Manager names -> values sourced from GitHub Secrets
          declare -A SECRET_VALUES=(
            [UPLOADS_ALLOWED_MIME]="${{ secrets.UPLOADS_ALLOWED_MIME }}"
            [MONGODB_URI]="${{ secrets.MONGODB_URI }}"
            [GCS_BUCKET_UPLOADS]="${{ secrets.GCS_BUCKET_UPLOADS }}"
            [CLERK_ISSUER]="${{ secrets.CLERK_ISSUER }}"
            [CLERK_AUDIENCE]="${{ secrets.CLERK_AUDIENCE }}"
          )

          echo "Setting up secrets for deployment service account: $DEPLOY_SA"

          for NAME in ${{ env.REQUIRED_SECRETS }}; do
            echo "::group::Secret $NAME"
          
            VALUE="${SECRET_VALUES[$NAME]}"
            if [[ -z "${VALUE}" ]]; then
              echo "::error::GitHub Secret value for $NAME is empty or not provided."
              exit 1
            fi

            # Create secret if it doesn't exist
            if ! gcloud secrets describe "$NAME" --project="$PROJECT" >/dev/null 2>&1; then
              printf %s "$VALUE" | gcloud secrets create "$NAME" \
                --project="$PROJECT" \
                --replication-policy="automatic" \
                --data-file=-
              echo "  - Created secret $NAME"
            else
              echo "  - Secret $NAME already exists"
            fi

            # Check if secret has versions, add one if missing
            VERSIONS_COUNT=$(gcloud secrets versions list "$NAME" --project="$PROJECT" --format='value(name)' | wc -l | tr -d ' ')
            if [[ "$VERSIONS_COUNT" -eq 0 ]]; then
              printf %s "$VALUE" | gcloud secrets versions add "$NAME" --project="$PROJECT" --data-file=-
              echo "  - Added initial version for $NAME"
            else
              echo "  - Secret $NAME has $VERSIONS_COUNT version(s)"
            fi

            # Ensure latest version is enabled
            LATEST_NUM="$(gcloud secrets versions list "$NAME" --project="$PROJECT" --format='value(name)' --limit=1 | sed 's/.*versions\///')"
            if [[ -n "$LATEST_NUM" ]]; then
              STATE="$(gcloud secrets versions describe "$LATEST_NUM" --secret="$NAME" --project="$PROJECT" --format='value(state)')"
              if [[ "$STATE" == "DISABLED" ]]; then
                gcloud secrets versions enable "$LATEST_NUM" --secret="$NAME" --project="$PROJECT"
                echo "  - Enabled $NAME:$LATEST_NUM"
              else
                echo "  - Latest version $LATEST_NUM is $STATE"
              fi
            fi

            # Grant Secret Accessor to deployment SA
            if ! gcloud secrets get-iam-policy "$NAME" --project="$PROJECT" --format="value(bindings[?role=='roles/secretmanager.secretAccessor'].members[])" | grep -q "serviceAccount:$DEPLOY_SA"; then
              gcloud secrets add-iam-policy-binding "$NAME" \
                --project="$PROJECT" \
                --member="serviceAccount:$DEPLOY_SA" \
                --role="roles/secretmanager.secretAccessor" \
                --quiet
              echo "  - Granted secretAccessor to $DEPLOY_SA"
            else
              echo "  - $DEPLOY_SA already has secretAccessor"
            fi

            echo "::endgroup::"
          done

  deploy-staging:
    needs: [setup-secrets]
    if: always() && (needs.setup-secrets.result == 'success' || needs.setup-secrets.result == 'skipped')
    runs-on: ubuntu-latest
    environment: staging
    defaults:
      run:
        working-directory: server
    permissions:
      contents: read
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: yarn
          cache-dependency-path: server/yarn.lock

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Lint, typecheck, tests
        run: |
          yarn lint
          yarn typecheck
          yarn test --ci

      - name: Build Docker image
        run: |
          docker build \
            --platform ${{ env.DOCKER_PLATFORM }} \
            -t ${{ secrets.GCP_ARTIFACT_REGISTRY_REPO }}/${{ secrets.SERVICE_NAME }}:${{ github.sha }} \
            .

      - name: Auth to GCP (Deployment Service Account)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}
          audience: 'https://github.com/akibrahimug/portfolio'

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure GCP project & enable APIs
        run: |
          gcloud config set project "${{ secrets.GCP_PROJECT }}"
          gcloud services enable \
            secretmanager.googleapis.com \
            run.googleapis.com \
            artifactregistry.googleapis.com \
            iamcredentials.googleapis.com || true

      - name: Configure Docker auth for Artifact Registry
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ secrets.GCP_ARTIFACT_REGISTRY_REPO }}"
          REG_HOST="${REPO%%/*}"
          if [[ ! "$REG_HOST" =~ ^[a-z0-9-]+-docker\.pkg\.dev$ ]]; then
            echo "::error::GCP_ARTIFACT_REGISTRY_REPO must look like '<region>-docker.pkg.dev/<project>/<repo>'"
            echo "Got: $REPO"
            exit 1
          fi
          gcloud auth configure-docker "$REG_HOST" --quiet

      - name: Push image
        run: docker push ${{ secrets.GCP_ARTIFACT_REGISTRY_REPO }}/${{ secrets.SERVICE_NAME }}:${{ github.sha }}

      - name: Verify secrets exist and are accessible
        shell: bash
        run: |
          set -euo pipefail
          PROJECT="${{ secrets.GCP_PROJECT }}"

          echo "Verifying required secrets exist and are accessible..."
          
          for NAME in ${{ env.REQUIRED_SECRETS }}; do
            echo "::group::Checking secret $NAME"
          
            # Check if secret exists
            if ! gcloud secrets describe "$NAME" --project="$PROJECT" >/dev/null 2>&1; then
              echo "::error::Secret $NAME does not exist in project $PROJECT"
              echo "Run the workflow with 'setup_secrets=true' or create manually"
              exit 1
            fi
          
            # Check if we can access the latest version
            if ! gcloud secrets versions access latest --secret="$NAME" --project="$PROJECT" >/dev/null 2>&1; then
              echo "::error::Cannot access secret $NAME. Check IAM permissions."
              exit 1
            fi
          
            # Check version count and state
            VERSIONS_COUNT=$(gcloud secrets versions list "$NAME" --project="$PROJECT" --format='value(name)' | wc -l | tr -d ' ')
            LATEST_NUM="$(gcloud secrets versions list "$NAME" --project="$PROJECT" --format='value(name)' --limit=1 | sed 's/.*versions\///')"
            STATE="$(gcloud secrets versions describe "$LATEST_NUM" --secret="$NAME" --project="$PROJECT" --format='value(state)')"
          
            echo "  - Secret $NAME: $VERSIONS_COUNT version(s), latest ($LATEST_NUM) is $STATE"
          
            if [[ "$STATE" != "ENABLED" ]]; then
              echo "::error::Latest version of $NAME is not ENABLED. Current state: $STATE"
              exit 1
            fi
          
            echo "::endgroup::"
          done
          
          echo "âœ… All secrets are accessible and enabled"

      - name: Grant bucket Object Admin + SA Token Creator to runtime SA
        shell: bash
        run: |
          set -euo pipefail
          SA="${{ secrets.GCP_SA_EMAIL }}"
          PROJECT="${{ secrets.GCP_PROJECT }}"

          # Read bucket name from Secret Manager
          BUCKET="$(gcloud secrets versions access latest --secret=GCS_BUCKET_UPLOADS --project="$PROJECT")"
          if [[ -z "$BUCKET" ]]; then
            echo "::error::Secret GCS_BUCKET_UPLOADS has no value."
            exit 1
          fi

          echo "Configuring permissions for bucket: gs://$BUCKET"

          # Allow object operations (for post-upload validations / listings)
          gcloud storage buckets add-iam-policy-binding "gs://${BUCKET}" \
            --member="serviceAccount:${SA}" \
            --role="roles/storage.objectAdmin" \
            --project="$PROJECT" \
            --quiet || true

          # Allow keyless V4 signing (IAM SignBlob) on Cloud Run
          gcloud iam service-accounts add-iam-policy-binding "$SA" \
            --member="serviceAccount:${SA}" \
            --role="roles/iam.serviceAccountTokenCreator" \
            --project="$PROJECT" \
            --quiet || true

      - name: Deploy to Cloud Run (staging)
        shell: bash
        run: |
          set -euo pipefail

          # Build --set-secrets flags dynamically from REQUIRED_SECRETS
          SECRET_FLAGS=""
          for NAME in ${{ env.REQUIRED_SECRETS }}; do
            SECRET_FLAGS="$SECRET_FLAGS --set-secrets=$NAME=$NAME:latest"
          done

          echo "Deploying to staging with secrets: ${{ env.REQUIRED_SECRETS }}"

          gcloud run deploy "${{ secrets.SERVICE_NAME }}-stg" \
            --image="${{ secrets.GCP_ARTIFACT_REGISTRY_REPO }}/${{ secrets.SERVICE_NAME }}:${{ github.sha }}" \
            --region="${{ secrets.GCP_REGION }}" \
            --project="${{ secrets.GCP_PROJECT }}" \
            --platform=managed \
            --allow-unauthenticated \
            --port=${{ env.CR_PORT }} \
            --set-env-vars=^:^NODE_ENV=${{ env.CR_ENV_NODE }}:API_BASE=${{ env.CR_ENV_API_BASE }}:WS_ORIGINS=${{ secrets.WS_ORIGINS }} \
            $SECRET_FLAGS \
            --min-instances=0 \
            --max-instances=10 \
            --concurrency=${{ env.CR_CONCURRENCY }} \
            --timeout=${{ env.CR_TIMEOUT }} \
            --service-account="${{ secrets.GCP_SA_EMAIL }}" \
            --quiet

      - name: Wait for staging to be Ready (and dump logs on failure)
        shell: bash
        run: |
          set -euo pipefail
          SERVICE="${{ secrets.SERVICE_NAME }}-stg"
          REGION="${{ secrets.GCP_REGION }}"
          PROJECT="${{ secrets.GCP_PROJECT }}"

          echo "Waiting for $SERVICE to become Readyâ€¦"
          for i in {1..30}; do
            STATUS="$(gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format='value(status.conditions[0].status)' 2>/dev/null || echo "")"
            if [[ "$STATUS" == "True" ]]; then
              echo "âœ… Service is Ready."
              exit 0
            fi
            echo "  Attempt $i/30: status=$STATUS"
            sleep 10
          done

          echo "::error::Service did not become Ready. Dumping detailsâ€¦"
          gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format=yaml || true

          REV="$(gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format='value(status.latestCreatedRevisionName)' || true)"
          if [[ -n "$REV" ]]; then
            echo "Recent error logs for $REV:"
            gcloud run logs read "$REV" --region="$REGION" --project="$PROJECT" --limit=200 --severity=ERROR --timestamps || true
          fi
          exit 1

      - name: Health check (staging)
        run: |
          echo "Testing staging endpoint..."
          curl -fsSL "${{ secrets.STAGING_URL }}/api/v1/readyz" | cat
          echo "âœ… Staging health check passed"

  promote-prod:
    needs: deploy-staging
    if: ${{ github.event_name == 'workflow_dispatch' || github.ref == 'refs/heads/master' }}
    runs-on: ubuntu-latest
    environment: production
    defaults:
      run:
        working-directory: server
    permissions:
      contents: read
      id-token: write

    steps:
      - uses: actions/checkout@v4

      - name: Auth to GCP (Deployment Service Account)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure project
        run: gcloud config set project "${{ secrets.GCP_PROJECT }}"

      - name: Verify secrets (production)
        shell: bash
        run: |
          set -euo pipefail
          PROJECT="${{ secrets.GCP_PROJECT }}"
          
          echo "Verifying production secrets..."
          for NAME in ${{ env.REQUIRED_SECRETS }}; do
            if ! gcloud secrets versions access latest --secret="$NAME" --project="$PROJECT" >/dev/null 2>&1; then
              echo "::error::Cannot access secret $NAME for production deployment"
              exit 1
            fi
          done
          echo "âœ… All secrets verified for production"

      - name: Grant bucket Object Admin + SA Token Creator (prod)
        shell: bash
        run: |
          set -euo pipefail
          SA="${{ secrets.GCP_SA_EMAIL }}"
          PROJECT="${{ secrets.GCP_PROJECT }}"
          BUCKET="$(gcloud secrets versions access latest --secret=GCS_BUCKET_UPLOADS --project="$PROJECT")"
          if [[ -z "$BUCKET" ]]; then
            echo "::error::Secret GCS_BUCKET_UPLOADS has no value."
            exit 1
          fi
          
          echo "Configuring production permissions for bucket: gs://$BUCKET"
          
          gcloud storage buckets add-iam-policy-binding "gs://${BUCKET}" \
            --member="serviceAccount:${SA}" \
            --role="roles/storage.objectAdmin" \
            --project="$PROJECT" \
            --quiet || true
          gcloud iam service-accounts add-iam-policy-binding "$SA" \
            --member="serviceAccount:${SA}" \
            --role="roles/iam.serviceAccountTokenCreator" \
            --project="$PROJECT" \
            --quiet || true

      - name: Deploy to Cloud Run (production)
        shell: bash
        run: |
          set -euo pipefail
          SECRET_FLAGS=""
          for NAME in ${{ env.REQUIRED_SECRETS }}; do
            SECRET_FLAGS="$SECRET_FLAGS --set-secrets=$NAME=$NAME:latest"
          done
          
          echo "Deploying to production with secrets: ${{ env.REQUIRED_SECRETS }}"
          
          gcloud run deploy "${{ secrets.SERVICE_NAME }}-prd" \
            --image="${{ secrets.GCP_ARTIFACT_REGISTRY_REPO }}/${{ secrets.SERVICE_NAME }}:${{ github.sha }}" \
            --region="${{ secrets.GCP_REGION }}" \
            --project="${{ secrets.GCP_PROJECT }}" \
            --platform=managed \
            --allow-unauthenticated \
            --port=${{ env.CR_PORT }} \
            --set-env-vars=^:^NODE_ENV=${{ env.CR_ENV_NODE }}:API_BASE=${{ env.CR_ENV_API_BASE }}:WS_ORIGINS=${{ secrets.WS_ORIGINS }} \
            $SECRET_FLAGS \
            --min-instances=1 \
            --max-instances=20 \
            --concurrency=${{ env.CR_CONCURRENCY }} \
            --timeout=${{ env.CR_TIMEOUT }} \
            --service-account="${{ secrets.GCP_SA_EMAIL }}" \
            --quiet

      - name: Wait for production Ready (and dump logs on failure)
        shell: bash
        run: |
          set -euo pipefail
          SERVICE="${{ secrets.SERVICE_NAME }}-prd"
          REGION="${{ secrets.GCP_REGION }}"
          PROJECT="${{ secrets.GCP_PROJECT }}"
          
          echo "Waiting for production service to become Readyâ€¦"
          for i in {1..30}; do
            STATUS="$(gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format='value(status.conditions[0].status)' 2>/dev/null || echo "")"
            if [[ "$STATUS" == "True" ]]; then
              echo "âœ… Production service is Ready."
              exit 0
            fi
            echo "  Attempt $i/30: status=$STATUS"
            sleep 10
          done
          
          echo "::error::Production service did not become Ready. Dumping detailsâ€¦"
          gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format=yaml || true
          REV="$(gcloud run services describe "$SERVICE" --region="$REGION" --project="$PROJECT" --format='value(status.latestCreatedRevisionName)' || true)"
          if [[ -n "$REV" ]]; then
            echo "Recent error logs for $REV:"
            gcloud run logs read "$REV" --region="$REGION" --project="$PROJECT" --limit=200 --severity=ERROR --timestamps || true
          fi
          exit 1

      - name: Health check (production)
        run: |
          echo "Testing production endpoint..."
          curl -fsSL "${{ secrets.PROD_URL }}/api/v1/readyz" | cat
          echo "âœ… Production deployment completed successfully"